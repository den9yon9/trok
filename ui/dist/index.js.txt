// ui/src/pages/index.tsx
import { render } from "preact";

// ui/src/service/index.ts
import { useCallback, useEffect, useState } from "preact/hooks";

// lib/mitt.ts
function mitt(all) {
  all = all || /* @__PURE__ */ new Map();
  return {
    /**
     * A Map of event names to registered handler functions.
     */
    all,
    /**
     * Register an event handler for the given type.
     * @param {string|symbol} type Type of event to listen for, or `'*'` for all events
     * @param {Function} handler Function to call in response to given event
     * @memberOf mitt
     */
    on(type, handler) {
      const handlers = all.get(type);
      if (handlers) {
        handlers.push(handler);
      } else {
        all.set(type, [handler]);
      }
    },
    /**
     * Remove an event handler for the given type.
     * If `handler` is omitted, all handlers of the given type are removed.
     * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)
     * @param {Function} [handler] Handler function to remove
     * @memberOf mitt
     */
    off(type, handler) {
      const handlers = all.get(type);
      if (handlers) {
        if (handler) {
          handlers.splice(handlers.indexOf(handler) >>> 0, 1);
        } else {
          all.set(type, []);
        }
      }
    },
    /**
     * Invoke all handlers for the given type.
     * If present, `'*'` handlers are invoked after type-matched handlers.
     *
     * Note: Manually firing '*' handlers is not supported.
     *
     * @param {string|symbol} type The event type to invoke
     * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler
     * @memberOf mitt
     */
    emit(type, evt) {
      let handlers = all.get(type);
      if (handlers) {
        handlers.slice().map((handler) => {
          handler(evt);
        });
      }
      handlers = all.get("*");
      if (handlers) {
        handlers.slice().map((handler) => {
          handler(type, evt);
        });
      }
    }
  };
}

// ui/src/service/index.ts
function notifyMe(message) {
  if (!("Notification" in window)) alert("\u5F53\u524D\u6D4F\u89C8\u5668\u4E0D\u652F\u6301\u684C\u9762\u901A\u77E5");
  else if (Notification.permission === "granted") new Notification(message);
  else if (Notification.permission !== "denied") {
    Notification.requestPermission().then((permission) => {
      if (permission === "granted") new Notification(message);
    });
  }
}
function useWorkspace() {
  const [workspace, setWorkspace] = useState([]);
  const fetchWorkspace = useCallback(
    () => void fetch("/workspace").then((res) => res.json()).then(setWorkspace),
    []
  );
  useEffect(() => void fetchWorkspace(), []);
  return { workspace, fetchWorkspace };
}
function useTaskHubList() {
  const [list, setList] = useState([]);
  const fetchTasks = useCallback(
    () => fetch("/task").then((res) => res.json()).then(setList),
    []
  );
  useEffect(() => void fetchTasks(), []);
  return { list, fetchTasks };
}
var Socket = class {
  static mitt = mitt();
  static client = new WebSocket(location.href.replace("http", "ws"));
  static timer;
  static {
    this.client.addEventListener("open", () => this.client.send("PING"));
    this.client.addEventListener("message", (e) => {
      if (e.data === "PONG") {
        setTimeout(() => this.client.send("PING"), 10 * 1e3);
      } else {
        const data = JSON.parse(e.data);
        this.mitt.emit("data", data);
      }
    });
    this.client.addEventListener("close", (e) => {
      clearInterval(this.timer);
      if (globalThis.confirm(`socket\u5DF2\u65AD\u5F00,code: ${e.code}, reason: ${e.reason}`)) globalThis.location.reload();
    });
  }
};
function useSnapshots() {
  const [snapshots, setSnapshots] = useState([]);
  useEffect(() => {
    fetch("/snapshot").then((res) => res.json()).then(setSnapshots).then(
      () => {
        Socket.mitt.on("data", (data) => {
          if (data.type === "snapshot") {
            notifyMe(
              {
                pending: "\u5F00\u59CB\u5904\u7406",
                progress: "\u5F00\u59CB\u6253\u5305",
                resolved: "\u5904\u7406\u5B8C\u6210",
                rejected: "\u5904\u7406\u5931\u8D25"
              }[data.data.status]
            );
            setSnapshots((snapshot) => [...snapshot, data.data]);
          }
        });
      }
    );
  }, []);
  return snapshots;
}

// ui/src/pages/index.tsx
import { useEffect as useEffect3, useState as useState3 } from "preact/hooks";

// ui/src/pages/components/TaskState.tsx
import { useEffect as useEffect2, useState as useState2 } from "preact/hooks";
import { Fragment, jsx, jsxs } from "preact/jsx-runtime";
function Code(props) {
  return /* @__PURE__ */ jsx(
    "pre",
    {
      title: props.title,
      className: `text-xs overflow-x-scroll bg-${props.theme}-content rounded text-${props.theme} p-2 my-2 max-h-80 max-w-5xl`,
      ref: (el) => el?.scrollTo(0, el.scrollHeight),
      children: /* @__PURE__ */ jsx("code", { children: props.children })
    }
  );
}
function Logs(props) {
  if (typeof props.logs === "string") return props.logs;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(Code, { title: "stdout", theme: "info", children: props.logs.stdout }),
    props.logs.signal,
    /* @__PURE__ */ jsx(Code, { title: "stderr", theme: "error", children: props.logs.stderr })
  ] });
}
function TaskState(props) {
  const [taskState] = props.snapshots.sort((a, b) => {
    const value = b.timestamp - a.timestamp;
    if (value !== 0) return value;
    return a.status === "pending" ? 1 : -1;
  });
  const [streamData, setStreamData] = useState2([]);
  useEffect2(() => {
    Socket.mitt.on("data", (data) => {
      if (data.type === "stream") {
        if (data.data.task.id === taskState.task.id) {
          setStreamData((value) => [...value, data.data]);
        }
      }
    });
  }, []);
  return /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsxs("div", { className: `flex flex-col items-start chat chat-start mb-5`, children: [
    /* @__PURE__ */ jsxs("div", { className: "chat-header opacity-50 mb-1 text-xs ", children: [
      taskState.task.origin,
      /* @__PURE__ */ jsx("span", { className: "text-xs badge badge-xs badge-primary mx-2", children: taskState.task.branch }),
      /* @__PURE__ */ jsx("span", { className: "kbd kbd-xs", children: taskState.task.selector })
    ] }),
    /* @__PURE__ */ jsxs(
      "div",
      {
        className: `chat-bubble min-w-80 relative chat-bubble-${{
          pending: "neutral",
          progress: "neutral",
          resolved: "success",
          rejected: "error"
        }[taskState.status]}`,
        children: [
          taskState.logs && /* @__PURE__ */ jsx(Logs, { logs: taskState.logs }),
          taskState.commits?.length ? /* @__PURE__ */ jsxs(Fragment, { children: [
            /* @__PURE__ */ jsx("h6", { children: "\u63D0\u4EA4\u8BB0\u5F55" }),
            /* @__PURE__ */ jsx("ul", { className: "text-xs", children: taskState.commits.map((commitItem) => /* @__PURE__ */ jsxs("li", { children: [
              "\u2726 ",
              commitItem
            ] })) })
          ] }) : null,
          streamData.filter((item) => !item.packagePath).length > 0 && taskState.status === "pending" && /* @__PURE__ */ jsx(Code, { title: "stream", theme: "info", children: streamData.filter((item) => !item.packagePath).map((item) => item.data).join("") }),
          taskState.packages?.length ? /* @__PURE__ */ jsxs(Fragment, { children: [
            /* @__PURE__ */ jsx("h6", { children: "\u9879\u76EE\u5217\u8868" }),
            /* @__PURE__ */ jsx("ul", { className: "text-xs", children: taskState.packages?.map((packageItem) => {
              const packageStream = streamData.filter(
                (item) => item.packagePath === packageItem.path
              );
              const pending = packageStream.length ? /* @__PURE__ */ jsx("span", { className: "loading loading-spinner text-warning loading-xs" }) : /* @__PURE__ */ jsx("span", { className: "text-warning", children: "-" });
              const rejected = /* @__PURE__ */ jsx("span", { className: "text-error", children: "\u2717" });
              const resolved = /* @__PURE__ */ jsx("span", { className: "text-primary", children: "\u2713" });
              return /* @__PURE__ */ jsxs(Fragment, { children: [
                /* @__PURE__ */ jsxs("li", { className: "text-sm flex items-center gap-2", children: [
                  { pending, rejected, resolved }[packageItem.status],
                  packageItem.path
                ] }),
                packageStream.length > 0 && packageItem.status === "pending" && /* @__PURE__ */ jsx(Code, { theme: "info", children: packageStream.map((item) => item.data).join("") }),
                packageItem.logs && /* @__PURE__ */ jsx(Logs, { logs: packageItem.logs })
              ] });
            }) })
          ] }) : null
        ]
      }
    ),
    /* @__PURE__ */ jsx("div", { className: "chat-footer opacity-50 text-xs mt-1", children: new Date(taskState.timestamp).toLocaleString() })
  ] }) });
}

// ui/src/pages/index.tsx
import { jsx as jsx2, jsxs as jsxs2 } from "preact/jsx-runtime";
function Workspace(props) {
  const { workspace } = useWorkspace();
  const [verbose, setVerbose] = useState3(false);
  return /* @__PURE__ */ jsxs2("div", { className: "flex flex-col gap-2 w-fit", children: [
    /* @__PURE__ */ jsx2("div", { className: "form-control w-full", children: /* @__PURE__ */ jsxs2("label", { className: "label cursor-pointer", children: [
      /* @__PURE__ */ jsx2("span", { className: "label-text text-bold", children: "\u6253\u5370\u8BE6\u7EC6\u4FE1\u606F" }),
      /* @__PURE__ */ jsx2(
        "input",
        {
          type: "checkbox",
          onChange: () => setVerbose(!verbose),
          className: "toggle toggle-primary",
          checked: verbose
        }
      )
    ] }) }),
    workspace.map((item) => {
      return /* @__PURE__ */ jsx2(
        "form",
        {
          className: "shadow bg-base-100 rounded-2xl p-2 flex flex-col gap-2 border-primary",
          onSubmit: (e) => {
            e.preventDefault();
            const form = new FormData(e.currentTarget);
            props.onCreateTask(
              item.origin,
              item.branch,
              form.get("selector"),
              verbose
            );
            e.currentTarget.reset();
          },
          children: /* @__PURE__ */ jsxs2("div", { className: "collapse collapse-arrow border", children: [
            /* @__PURE__ */ jsx2("input", { type: "checkbox" }),
            /* @__PURE__ */ jsxs2("div", { className: "collapse-title", children: [
              /* @__PURE__ */ jsx2("span", { children: item.origin }),
              /* @__PURE__ */ jsx2("span", { className: "badge badge-primary badge ml-2", children: item.branch })
            ] }),
            /* @__PURE__ */ jsxs2("div", { className: "collapse-content", children: [
              /* @__PURE__ */ jsx2("div", { className: "flex flex-wrap justify-center gap-1", children: item.packages.map((item2) => /* @__PURE__ */ jsx2(
                "input",
                {
                  type: "radio",
                  "aria-label": item2,
                  name: "selector",
                  className: "btn btn-xs btn-outline",
                  value: item2
                },
                item2
              )) }),
              /* @__PURE__ */ jsx2("button", { className: "btn btn-primary block btn-wide mt-5 mx-auto btn-sm", children: "\u63D0\u4EA4\u4EFB\u52A1" })
            ] })
          ] })
        },
        item.path
      );
    })
  ] });
}
function TaskHubList(props) {
  return /* @__PURE__ */ jsx2("div", { className: "stack fixed bottom-2 right-2", children: props.list.map((item) => {
    return /* @__PURE__ */ jsxs2("div", { className: "shadow rounded-lg p-4 bg-base-100 border text-center text-sm", children: [
      item.origin,
      /* @__PURE__ */ jsx2("span", { className: "badge badge-primary badge-sm mx-2", children: item.branch }),
      /* @__PURE__ */ jsx2("span", { className: "kbd kbd-sm", children: item.selector })
    ] });
  }) });
}
function Main() {
  const snapshots = useSnapshots();
  const snapShotGroups = Object.values(
    Object.groupBy(snapshots, (item) => item.task.id)
  );
  const { list, fetchTasks } = useTaskHubList();
  useEffect3(() => {
    Socket.mitt.on("data", (data) => {
      if (data.type === "snapshot") void fetchTasks();
    });
  }, []);
  return /* @__PURE__ */ jsxs2("div", { className: "flex gap-2 w-screen", children: [
    /* @__PURE__ */ jsx2("div", { className: "p-2 bg-base-200 h-screen overflow-y-scroll max-w-96", children: /* @__PURE__ */ jsx2(
      Workspace,
      {
        onCreateTask: async (origin, branch, selector, verbose) => {
          await fetch("/task", {
            method: "POST",
            body: JSON.stringify({
              origin,
              branch,
              selector,
              verbose
            })
          });
          fetchTasks();
        }
      }
    ) }),
    /* @__PURE__ */ jsx2(
      "div",
      {
        className: "p-2 h-screen overflow-y-scroll grow",
        ref: (el) => el?.scrollTo(0, el.scrollHeight),
        children: snapShotGroups.map((item) => /* @__PURE__ */ jsx2(TaskState, { snapshots: item }))
      }
    ),
    /* @__PURE__ */ jsx2(TaskHubList, { list })
  ] });
}
render(/* @__PURE__ */ jsx2(Main, {}), document.getElementById("root"));
